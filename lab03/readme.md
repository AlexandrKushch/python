# Рядки, масивоподібні структури даних, модуль Random
# Лабораторна №3
### Ціль: Навчитись використовувати масивоподібні структури, заповнювати їх рандомними значеннями. Ознайомитись з функціоанлом рядків

Для першої програми створюємо два масиви. Перший - з рандомниим значеннями. Другий - результат.
Щоб задати рандомними значеннями використовуємо цикл для заповнення кожного елементу, та використовуємо
метод **random.randint(-60, 60)** - який повертає ціле число у діапазоні [-60, 60]

Виводимо масив на екран. Потім у користувача запрошуємо ввести діапазон [x, y], 
за допомогою методу **input()**

У циклі до першого від`ємного числа перевіряємо чи входить елемент у діапазон.
Якщо так, то записуємо у результуючий(другий) масив:

### Результат роботи програми <br>
> Enter the length of list <br>
> 20 <br>
> 15, -44, 50, -38, 36, -24, -45, 34, -7, -21, 59, 40, -48, -5, -51, 5, -36, -58, -25, -39 <br>
> Enter x and y <br>
> 10 <br>
> 20 <br>
> New Array <br>
> 15 <br>
> Length of New Array 1 <br>

Для другої програми створюємо двовимірний масив. Для цього потрібно створити одновимірний і у циклі 
кожному елементу присвоїти ще по одному масиву. І потім за допомогою циклу у циклі заповнюємо
масив рандомними дрібними значеннями, використовуючи метод **random.uniform(-10, 10)**.

Пошук стовпця з мінімальним елементом матриці:
- Створюємо дві змінні: 
  - **minimum** - зберігає в собі мінімальний елемент масиву
  - **minimum_kry** - зберігає стовпець в якому знаходиться мінімальний елемент масиву.
- Циклом проходимось по масиву, якщо знаходимо елемент масиву який менше ніж **minimum**.
То відновлюємо значення змінних **minimum** та **minimum_kry**

Заміна стовпця з мінімальним елементом матриці та з останнім виконана наступним чином:
- Циклом проходимось по масиву.
- Міняємо місцями кожний елемент останнього стовпця та елемент стовпця з мінімальним елементом.

### Результат роботи програми
> N and M value <br>
5 <br>
5 <br>
Default: <br>
-0.38740671925715375 -9.346187042725502 8.834138020085664 -1.1418803673543785 0.30060858612375796  <br>
-6.341397843530805 -0.4349669494894659 5.913669556725679 5.915754700315485 -2.2683965118576648  <br>
3.557143746449789 4.273883400857274 7.672044628295506 -0.6804351360474712 -6.474869238477162  <br>
-7.5205251064897 3.570373430677403 4.418724511438224 5.868768472966472 -5.292618295780304  <br>
-9.468241336033394 0.1963281784383497 5.5654151202510995 9.845111468258509 -7.769269425140031  <br>
MinElem: -9.468241336033394 Column 0 <br>
Replaced: <br>
0.30060858612375796 -9.346187042725502 8.834138020085664 -1.1418803673543785 -0.38740671925715375  <br>
-2.2683965118576648 -0.4349669494894659 5.913669556725679 5.915754700315485 -6.341397843530805  <br>
-6.474869238477162 4.273883400857274 7.672044628295506 -0.6804351360474712 3.557143746449789  <br>
-5.292618295780304 3.570373430677403 4.418724511438224 5.868768472966472 -7.5205251064897  <br>
> -7.769269425140031 0.1963281784383497 5.5654151202510995 9.845111468258509 -9.468241336033394  <br>

Для третьої програми потрібно запросити речення у користувача методом **input()**, при цьому конвертувати у тип *строки* не потрібно! 
Після чого обробити двома методами, **strip()** - щоб позбутися зайвих пробілів зліва та справа речення. 
**replace("-", " ")** - щоб замінити символ "-" на " ".

Потім перевірка, якщо в реченні більше ніж десять слів то завершаємо програму. Перевірка відбувається 
за допомогою підрахунку пробілів у речення методом **count(" ")**. 

Алгоритм створення нового речення без слів які повторюються:
- У масив строк записуємо всі слова введеного речення, методом **split()**,
  який розбиває речення на окремі слова за символом " "
- Проходимось по цьому масиву, якщо поточний елемент у реченні повторюється тільки один раз
то записуємо у результуючу змінну, перевірка виконується за допомогою методу **sentence.count(i)**.
  
### Результат роботи програми
>               hello world-hello how are you, world? (Те що ввели)
> hello world hello how are you, world? <br>
> how are you, world? <br>